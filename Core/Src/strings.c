#include "strings.h"

uint8_t StrLength(uint8_t *sa)
{
	uint8_t len = 0;
	for (;*sa;len++,sa++);
	return len;
}

//===============================================================================================
// Сравнение строк /////////////////////////////////////////////////////////////////////////////
//===============================================================================================
bool StrComp(uint8_t *sa, uint8_t *sb)
{
	while (*sa)						// Пока данные по указателю sa не равны нулю, а они равны нулю в конце строки.
		if (*sa++!=*sb++)		// Если символы не равны, то выдать отрицательный ответ. Чем раньше не равны, тем быстрее.
			return false;
	return true;						// Если все прошло успешно, выдать OK
}

//===============================================================================================
// Копирование строк ///////////////////////////////////////////////////////////////////////////
//===============================================================================================
void StrCopy(uint8_t *sa, uint8_t *sb, uint8_t max) //Записать строку sb в строку sa
{
	do
	{
		*sa++=*sb++;					// Присвоить посимвольно
		max--;
	}
	while (*sb && max);			// Пока данные по указателю sb не равны нулю (а они равны нулю в конце строки) и не вышли за максимальный предел.
	*sa=0;									// Записать 0 после данных (на случай, если нуля там нет).
}

//===============================================================================================
// Копирование строки на определенное место в другую строку ////////////////////////////////////
//===============================================================================================
uint8_t StrCopyIn(uint8_t *sa, uint8_t *sb, uint8_t pos, uint8_t max) //Записать строку sb в строку sa на место pos
{
	if (*sb)
	{
		sa+=pos;								// Установить место
		do
		{
			*sa++=*sb++;					// Присвоить посимвольно
			pos++;
			max--;
		}
		while (*sb && max);			// Пока данные по указателю sb не равны нулю, а они равны нулю в конце строки.
	}
	return pos;								// Вернуть новое положение символа (старое + сколько прибавилось)
}

//===============================================================================================
// Очистка строки //////////////////////////////////////////////////////////////////////////////
//===============================================================================================
void StrClear(uint8_t *s, uint8_t length) //Очистить строку длинной length
{
	uint32_t counter = 0;
	while (length--) s[counter++]=0;
}

//===============================================================================================
// Преобразование строки в int32 ///////////////////////////////////////////////////////////////
//===============================================================================================
int32_t StrToInt(uint8_t *string)
{
	int32_t number = 0;											// Начальное значение числа
	int32_t negative = 0;										// Начальное значение знака (положительное число)
	if(*string == '-')											// Проверка знака, установка флага отрицательного числа
	{
		negative = 1;
		string++;
	}
	else
		if(*string == '+')
			string++;
	while(*string >= '0' && *string <= '9')	// Пока в строке есть числа
	{
		number *= 10;													// Сдвинуть влево на 1 разряд все число
		number += *(string++) - '0';					// Прибавить к числоу номер
	}
	if(negative)
		number = 0 - number;									// Если был минус в начале, сделать отрицательным
	return number;
}

//===============================================================================================
// Преобразование строки в float ///////////////////////////////////////////////////////////////
//===============================================================================================
float StrToFloat(uint8_t *string)
{
	float number = 0;												// Начальное значение числа
	int32_t negative = 0;										// Начальное значение знака (положительное число)
	float mantissa = 0;											// Позиция номера в мантиссе
	if(*string == '-')											// Проверка знака, установка флага отрицательного числа
	{
		negative = 1;
		string++;
	}
	else
		if(*string == '+')
			string++;
	while((*string >= '0' && *string <= '9') ||  (*string == '.'))	// Пока в строке есть числа
	{
		if (*string != '.')
			if (mantissa)
			{
				mantissa /= 10.0;//*= 0.1;									// Следующий дробный разряд
				number += (*(string++) - '0')* mantissa;	// Прибавить разряд к числу
			}
			else
			{
				number *= 10;															// Сдвинуть влево на 1 разряд все число
				number += *(string++) - '0';							// Прибавить к числоу номер
			}
		else
		{
			mantissa = 1.0;
			string++;
		}
	}
	if(negative)
		number = 0 - number;									// Если был минус в начале, сделать отрицательным
	return number;
}

//===============================================================================================
// Преобразование строки в double //////////////////////////////////////////////////////////////
//===============================================================================================
double StrToDouble(uint8_t *string)
{
	double number = 0;											// Начальное значение числа
	int32_t negative = 0;										// Начальное значение знака (положительное число)
	double mantissa = 0;										// Позиция номера в мантиссе
	if(*string == '-')											// Проверка знака, установка флага отрицательного числа
	{
		negative = 1;
		string++;
	}
	else
		if(*string == '+')
			string++;
	while((*string >= '0' && *string <= '9') ||  (*string == '.'))	// Пока в строке есть числа
	{
		if (*string != '.')
			if (mantissa)
			{
				mantissa /= 10.0;//*= 0.1;									// Следующий дробный разряд
				number += (*(string++) - '0')* mantissa;	// Прибавить разряд к числу
			}
			else
			{
				number *= 10;															// Сдвинуть влево на 1 разряд все число
				number += *(string++) - '0';							// Прибавить к числоу номер
			}
		else
		{
			mantissa = 1.0;
			string++;
		}
	}
	if(negative)
		number = 0 - number;									// Если был минус в начале, сделать отрицательным
	return number;
}

//===============================================================================================
// Преобразование типа int16 в строку //////////////////////////////////////////////////////////
//===============================================================================================
void IntToStr(int32_t data, uint8_t *str, uint8_t sign, uint8_t digits)
{
	// определение знака
	bool zero = false;
	if (sign)
	if (data < 0) {
		*str = '-';
		str++;
		data = -data;
	}

	uint8_t i = 0;
	if (digits > 4) {
		while (data >= 10000) { data -= 10000; i++; }
		if (i) { *str = i + 0x30; zero = true; } else *str = ' ';
		str++;
	}

	i = 0;
	if (digits > 3) {
		while (data >= 1000) { data -= 1000; i++; }
		if (i || zero)  { *str = i + 0x30; zero = true; } else *str = ' ';
		str++;
	}

	i = 0;
	if (digits > 2) {
		while (data >= 100) { data -= 100; i++; }
		if (i || zero) { *str = i + 0x30; zero = true; } else *str = ' ';
		str++;
	}

	i = 0;
	if (digits > 1) {
		while (data >= 10) { data -= 10; i++; }
		if (i || zero) *str = i + 0x30; else *str = ' ';
		str++;
	}

	*str = data + 0x30;
}

void IntToStrZero(int32_t data, uint8_t *str, uint8_t sign, uint8_t digits)
{
	// определение знака
	if (sign)
	if (data < 0)
	{
		*str = '-';
		str++;
		data = -data;
		digits--;
	}

	uint8_t i = 0;
	if (digits > 4) {
		while (data >= 10000) { data -= 10000; i++; }
		*str = i + 0x30;
		str++;
	}

	i = 0;
	if (digits > 3) {
		while (data >= 1000) { data -= 1000; i++; }
		*str = i + 0x30;
		str++;
	}

	i = 0;
	if (digits > 2) {
		while (data >= 100) { data -= 100; i++; }
		*str = i + 0x30;
		str++;
	}

	i = 0;
	if (digits > 1) {
		while (data >= 10) { data -= 10; i++; }
		*str = i + 0x30;
		str++;
	}

	*str = data + 0x30;
}

//===============================================================================================
// Преобразование типа char в HEX //////////////////////////////////////////////////////////////
//===============================================================================================
void CharToHex(uint8_t data, uint8_t *str)
{
	char symb;
	symb = data >> 4;
	if (symb > 9)
		str[0] = symb + 0x37;
	else
		str[0] = symb + 0x30;
	data &= 0x0F;
	if (data > 9)
		str[1] = data + 0x37;
	else
		str[1] = data + 0x30;
	str[2] = 0;
}

//===============================================================================================
// Преобразование типа Double в строку /////////////////////////////////////////////////////////
//===============================================================================================
void DoubleToStr(double value, uint8_t *string, uint8_t intdigits, uint8_t digits)
{
	uint8_t		tmpstring[10] = {0x00};
	uint8_t		position	=0;
	int32_t		temp			=0;
	uint32_t		digits_10	=1;
	uint8_t		count			=digits;

	temp = (int32_t)value;
	IntToStr((int16_t)temp, tmpstring, 1, intdigits);
	if(temp<0) intdigits++;
	position = StrCopyIn(string,tmpstring,position,intdigits);
	string[position++]='.';
	value -= (double)temp;
	while (count)
	{
		digits_10*=10;
		count--;
	}
	if (value<0) value=-value;
	value*=digits_10;
	temp = (int32_t) (value);//0.5+
	IntToStr((int16_t)temp, tmpstring, 0, digits);
	position = StrCopyIn(string,tmpstring,position,digits);
	string[position++]=0x00;
}

//===============================================================================================
// Преобразование типа float в строку /////////////////////////////////////////////////////////
//===============================================================================================
void FloatToStr(float value, uint8_t *string, uint8_t intdigits, uint8_t digits)
{
	uint32_t	digits_10 = 1;
	uint8_t count = digits;

	// Целая часть
	int16_t temp = (int16_t)value;
	IntToStr(temp, string, 1, intdigits);
	// Точка
	string += intdigits;
	*string = '.';
	string++;
	// Дробная часть
	value -= (float)temp;
	while (count--) digits_10 *= 10;
	value *= digits_10;
	temp = (uint16_t)value;
	IntToStrZero(temp, string, 0, digits);
}

//===============================================================================================
// Преобразование типа HEX в char //////////////////////////////////////////////////////////////
//===============================================================================================
uint8_t HexToChar(uint8_t *str)
{
	uint8_t symb1 = str[0];
	uint8_t symb2 = str[1];
	uint8_t data = 0;
	UpCase(str);
	if (((symb1 >=0x30 && symb1 <=0x39) || (symb1 >=0x41 && symb1 <=0x46)) &&
			((symb2 >=0x30 && symb2 <=0x39) || (symb2 >=0x41 && symb2 <=0x46)))
	{
		if (symb1 <= 0x39)
			data = ((symb1-0x30) & 0x0F) << 4;
		else
			data = ((symb1-0x37) & 0x0F) << 4;
		if (symb2 <= 0x39)
			data |=((symb2-0x30) & 0x0F);
		else
			data |=((symb2-0x37) & 0x0F);
	}
	return data;
}

//===============================================================================================
// Преобразовать в верхний регистр /////////////////////////////////////////////////////////////
//===============================================================================================
void UpCase(uint8_t *s) {
	do if ((*s>=0x61) && (*s<=0x7A)) *s -= 0x20;
	while (*s);
}

//===============================================================================================
// Преобразовать в нижний регистр //////////////////////////////////////////////////////////////
//===============================================================================================
void DownCase(uint8_t *s) {
	do if ((*s>=0x41) && (*s<=0x5A)) *s += 0x20;
	while (*s);
}
